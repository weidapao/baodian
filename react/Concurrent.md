# 定义
原:一旦它们开始渲染一次更新，它们不能中断包括创建新的 DOM 节点和运行组件中代码在内的工作.这个叫'阻塞渲染'
Concurrent调度模式:渲染不是阻塞的。它是可中断的
"同时执行多个更新任务"指的是同时将多个更新任务添加到React调度的任务队列中，然后React会一个个执行
任何一个更新任务都可以被更高优先级中断插队，在高优先级任务执行之后再执行

例子：有了版本控制工具，就能许多人同时修改一个文件

## 时间切片的作用
执行完一个时间切片准备执行下一个时间切片前
- 判断是否有用户界面交互事件和其他需要执行的代码，比如点击事件，有的话则执行该事件
- 判断是否有优先级更高的任务需要执行，如果有，则中断当前任务，执行更高的优先级任务。也就是利用时间前片来实现高优先级任务插队

## requestIdleCallback
requestIdleCallback(callback, { timeout: number })是浏览器提供的一种可以让回调函数执行在每帧（上图2个vsync之间即为1帧）末尾的空闲阶段的方法，配置timeout后，若多帧持续没有空闲时间,超过timeout时长后，该回调函数将立即被执行。
在 Layout 与 Paint 之后执行

## render 阶段与 commit 阶段
render阶段可以被打断
commit带有dom更新，一次性执行完

## 任务的拆分、中断、恢复
```
while (当前还有空闲时间 && 下一个节点不为空) {
  下一个节点 = 子节点 = beginWork(当前节点);
  if (子节点为空) {
    下一个节点 = 兄弟节点 = completeUnitOfWork(当前节点);
  }
  当前节点 = 下一个节点;
}
```
render 阶段遍历 Fiber 树的过程会在上述 while 循环中进行，每结束一次循环就会进行一次时间片的检查，如果时间片到了，while 循环将被 break，相当于 render 过程暂时被中断，当前处理到的节点会被保留下来，等待下一个时间分片到来时，继续处理.
如何检查：运行一次异步的MessageChannel的port.postMessage(...)方法，检查是否存在事件响应、更高优先级任务或其他代码需要执行


## 新的api
MessageChannel：浏览器提供的一种数据通信接口，实现发布订阅
Fiber：节点对象，react用链表的形式将所有fiber节点连接，即虚拟dom树

在执行调度工作循环和计算工作循环时，执行每一个工作中Fiber。但是，有一个条件是每隔5毫秒，会跳出工作循环，运行一次异步的MessageChannel的port.postMessage(...)方法，检查是否存在事件响应、更高优先级任务或其他代码需要执行，如果有则执行，如果没有则重新创建工作循环，执行剩下的工作中Fiber在执行调度工作循环和计算工作循环时，执行每一个工作中Fiber。但是，有一个条件是每隔5毫秒，会跳出工作循环，运行一次异步的MessageChannel的port.postMessage(...)方法，检查是否存在事件响应、更高优先级任务或其他代码需要执行，如果有则执行，如果没有则重新创建工作循环，执行剩下的工作中Fiber